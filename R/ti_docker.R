#' Create a TI method from a docker(hub) container
#'
#' @param container The name of the container. Required
#' @param name The name of the method. Optional, will be extracted from the container definition.yml file
#' @param input Input data, such as expression, counts or prior_information
#' @param output Output generated by the method
#' @param par_set The parameter set as created by [ParamHelpers::makeParamSet]
#' @param parameters A named list of parameters, containing the type of parameter and additional parameters such as lower and upper bounds, default value and/or possible values. Optional, will be extracted from the container definition.yml file
#' @param definition A list containing the name, container, input, output and parameters of a method. Usually used for when these values are loaded from a yaml or json file
#' @param pull Whether to pull the container first
#' @param docker_client Optional, a [stevedore::docker_client()]
#'
#' @importFrom jsonlite write_json read_json
#' @importFrom glue glue
#'
#' @export
create_docker_ti_method <- function(
  container,
  name = NULL,
  input = NULL,
  output = NULL,
  par_set = NULL,
  parameters = NULL,
  definition = NULL,
  pull = TRUE,
  docker_client = stevedore::docker_client()
) {
  testthat::expect_s3_class(docker_client, "docker_client")
  testthat::expect_true(is.logical(pull))

  # pull image
  if (pull) {
    docker_client$image$pull(container)
  }

  # extract from container if required parameters are not specified
  if (any(map_lgl(list(name, input, output), is.null))) {
    message("Extracting method definition from container definitions.yml file")

    temp_container <- docker_client$container$create(
      container,
      "bash",
      entrypoint="bash"
    )
    definition_path <- tempfile()
    system(glue("docker cp {temp_container$id()}:/code/definition.yml {definition_path}"))
    temp_container$remove()

    definition <- yaml::read_yaml(definition_path)
  }

  # extract parameters from definition if given
  if (!is.null(definition)) {
    if(is.null(name)) name <- definition$name
    if(is.null(input)) input <- definition$input
    if(is.null(output)) output <- definition$output
    if(is.null(parameters) && is.null(par_set)) parameters <- definition$parameters
  }

  testthat::expect_true(is.character(name))
  testthat::expect_true(is.character(container))
  testthat::expect_true(is.character(input))
  testthat::expect_true(is.character(output))

  # parse parameters
  if(is.null(par_set)) {
    if(is.null(parameters)) stop("parameters is required if par_set is not given")

    parse_parameter_definition <- function(parameter_definition) {
      map2(names(parameter_definition), parameter_definition, function(id, p) {
        with(
          p,
          if(type == "integer") {
            ParamHelpers::makeIntegerParam(id, lower=lower, upper=upper, default=default)
          } else {
            stop("invalid type")
          }
        )
      }) %>%
        do.call(ParamHelpers::makeParamSet, .)
    }
    par_set <- parse_parameter_definition(parameters)
  }

  # extract the input, params and output
  input_ids <- input
  param_ids <- names(par_set$pars)
  output_ids <- output

  if (!any(input_ids %in% input_processors$id)) {
    stop("Invalid input_ids: ", setdiff(input_ids, input_processors$id))
  }

  if (!any(output_ids %in% output_processors$id)) {
    stop("Invalid output_ids: ", setdiff(input_ids, output_processors$id))
  }

  # define run_fun
  run_fun <- function() {
    # create input directory
    dir_input <- file.path(tempdir(), "input")
    if(dir.exists(dir_input)) {
      unlink(dir_input)
    } else {
      dir.create(dir_input)
    }

    # create output directory
    dir_output <- file.path(tempdir(), "output")
    if(dir.exists(dir_output)) {
      unlink(dir_output)
    } else {
      dir.create(dir_output)
    }

    # save inputs
    for (input_id in input_ids) {
      save_input(get(input_id, environment()), input_id, file.path(dir_input, input_id))
    }

    # save params
    params <- map(param_ids, get, environment()) %>% set_names(param_ids)
    write_json(params, file.path(dir_input, "params.json"))

    # print provided input files
    list.files(dir_input) %>%
      crayon::bold() %>%
      glue::collapse("\n\t") %>%
      paste0("input: \n\t", ., "\n") %>%
      cat

    # run docker container
    docker <- stevedore::docker_client()

    if (pull) {
      docker_client$image$pull(container)
    }

    docker_client$container$run(
      container,
      volumes=c(
        glue("{dir_input}:/input"),
        glue("{dir_output}:/output")
      )
    )

    # print found output files
    list.files(dir_output) %>%
      crayon::bold() %>%
      glue::collapse("\n\t") %>%
      paste0("output: \n\t", ., "\n") %>%
      cat

    # wrap output
    if(exists("counts")) {cell_ids <- rownames(counts)} else {cell_ids <- rownames(expression)}
    model <- wrap_data(cell_ids = cell_ids) %>%
      wrap_output(output_ids, dir_output)

    model
  }

  # adapat run_fun environment
  environment(run_fun) <- list2env(lst(input_ids, param_ids, output_ids))

  # adapt run_fun arguments
  argument_ids <- c(input_ids, param_ids)
  arguments <- c(
    rep(list(expr()), length(argument_ids)) %>% set_names(argument_ids),
    alist(pull=TRUE, docker_client=stevedore::docker_client()) # default pull and docker_client arguments
  )
  formals(run_fun) <- arguments

  # create ti_method
  create_ti_method(
    name,
    par_set,
    run_fun
  )
}



input_processors <- tribble(
  ~id, ~processor,
  "expression", function(x, path) {write.csv(x, paste0(path, ".csv"))},
  "start_cells", function(x, path) {write_json(x, paste0(path, ".json"))}
)

save_input <- function(x, input_id, path) {
  input_processors$processor[[which(input_processors$id == input_id)]](x, path)
}



output_processors <- tribble(
  ~id, ~processor,
  "linear", function(model, dir_output) {
    pseudotimes <- read_csv(
      file.path(dir_output, "pseudotimes.csv"),
      col_types = cols(
        cell_id = col_character(),
        pseudotime = col_double()
      )

    ) %>%
    {set_names(.$pseudotime, .$cell_id)}

    model %>% add_linear_trajectory(pseudotimes)
  }
)

wrap_output <- function(model, output_ids, dir_output) {
  for (output_id in output_ids) {
    model <- output_processors$processor[[which(output_processors$id == output_id)]](model, dir_output)
  }

  model
}
